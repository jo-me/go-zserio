{{- $scope := .pkg }}
{{- $field := .field }}
{{- $native := goNativeType $scope $field.Type }}
{{- $name := printf "v.%s" $field.Name }}
{{- if $field.IsOptional}}
    {{- $name = printf "(*v.%s)" $field.Name }}
{{- end }}
{{- if and $native.RequiresCast (not $field.Array) }}
    {{- if $native.IsMarshaler }}
        {{- $name = printf "(*%s)(&v.%s)" (goType $scope $native.Type) $field.Name }}
        {{- if $field.IsOptional}}
            {{- $name = printf "(*%s)(v.%s)" (goType $scope $native.Type) $field.Name }}
        {{- end }}
    {{- else }}
        {{- $name = printf "%s(%s)" (goType $scope $native.Type) $name }}
    {{- end }}
{{- end }}

{{- if $field.OptionalClause }}
    if {{ goExpression $scope $field.OptionalClause }} {
{{- end }}
{{- if not (eq $field.Alignment 0) }}
    endBitPosition += ztype.CountAlignBits(endBitPosition, {{ $field.Alignment }})
{{- end }}

{{- if $field.IsOptional}}
    endBitPosition += 1
    if v.{{ $field.Name }} != nil {
{{- end }}

{{- if $field.Array }}
    {{- template "array_init.go.tmpl" dict "pkg" $scope "field_name" $name "field" $field "native" $native }}
    {{- if $native.IsMarshaler }}
    // The array type is a zserio object. The array traits expect array of
    // pointers, so convert from array of struct to array of struct pointers
    for index, _ := range {{ $name }} {
        {{ $field.Name }}PtrArray = append({{ $field.Name }}PtrArray, &{{ $name }}[index])
    }
    {{- end }}
    {{- $name = printf "%sArrayProperties" $field.Name }}
{{- end }}
{{ template "builtin_bitsizeof.go.tmpl" dict "pkg" $scope "name" $name "native" $native "isarray" $field.Array }}

{{- if $field.IsOptional}}
    }
{{- end}}
{{- if $field.OptionalClause }}
    }
{{- end }}
