// Code generated by go-zserio. DO NOT EDIT.

package schema

import (
	"errors"
	zserio "github.com/woven-planet/go-zserio"
	"github.com/woven-planet/go-zserio/ztype"
)

type SubTypeArithmetics struct {
	Value1 SubtypedInt32 `json:"value1"`

	Value2 SubtypedVarUint64 `json:"value2"`

	Value3 SubtypedFloat64 `json:"value3"`

	Value4 int64 `json:"value4"`

	Value5 DoubleSubtypedFloat64 `json:"value5"`

	ColourValue Colour `json:"colourValue"`
}

func (v *SubTypeArithmetics) Clone() zserio.ZserioType {
	clone := &SubTypeArithmetics{}
	*clone = *v
	return clone
}

func (v *SubTypeArithmetics) LoadDefaultValues() error {

	if err := v.ColourValue.LoadDefaultValues(); err != nil {
		return err
	}

	return nil
}

// MarshalZserio implements the zserio.Marshaler interface.
func (v *SubTypeArithmetics) MarshalZserio(w zserio.Writer) error {
	var err error

	if err = ztype.WriteInt32(w, int32(v.Value1)); err != nil {
		return err
	}

	if err = ztype.WriteVaruint64(w, uint64(v.Value2)); err != nil {
		return err
	}

	if err = ztype.WriteFloat64(w, float64(v.Value3)); err != nil {
		return err
	}

	if err = ztype.WriteInt64(w, v.Value4); err != nil {
		return err
	}

	if err = ztype.WriteFloat64(w, float64(v.Value5)); err != nil {
		return err
	}

	if err = v.ColourValue.MarshalZserio(w); err != nil {
		return err
	}

	_ = err // to avoid "declared but not used" warning
	return nil
}

// UnmarshalZserio implements the zserio.Unmarshaler interface.
func (v *SubTypeArithmetics) UnmarshalZserio(r zserio.Reader) error {
	var err error

	if tempValue, err := ztype.ReadInt32(r); err == nil {
		v.Value1 = (SubtypedInt32)(tempValue)
	} else {
		return err
	}

	if tempValue, err := ztype.ReadVaruint64(r); err == nil {
		v.Value2 = (SubtypedVarUint64)(tempValue)
	} else {
		return err
	}

	if tempValue, err := ztype.ReadFloat64(r); err == nil {
		v.Value3 = (SubtypedFloat64)(tempValue)
	} else {
		return err
	}

	if tempValue, err := ztype.ReadInt64(r); err == nil {
		v.Value4 = (int64)(tempValue)
	} else {
		return err
	}

	if tempValue, err := ztype.ReadFloat64(r); err == nil {
		v.Value5 = (DoubleSubtypedFloat64)(tempValue)
	} else {
		return err
	}

	if err = v.ColourValue.UnmarshalZserio(r); err != nil {
		return err
	}

	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *SubTypeArithmetics) RetunSum() float64 {
	retVal := float64(uint64(v.Value1)+uint64(v.Value2)) + float64(v.Value3) + float64(16) + float64(v.Value4) + float64(v.Value5) + float64(v.ColourValue)
	return float64(retVal)
}

// ZserioBitSize implements the zserio.Marshaler interface.
func (v *SubTypeArithmetics) ZserioBitSize(bitPosition int) (int, error) {
	endBitPosition := bitPosition

	endBitPosition += 32

	if delta, err := ztype.UnsignedBitSize(uint64(v.Value2), 8); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	endBitPosition += 64

	endBitPosition += 64

	endBitPosition += 64

	if delta, err := v.ColourValue.ZserioBitSize(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	return endBitPosition - bitPosition, nil
}

func (v *SubTypeArithmetics) ZserioCreatePackingContext(contextNode *zserio.PackingContextNode) error {

	fieldValue1Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValue1Node)
	// The field can be directly delta packed, therefore create a delta context
	fieldValue1Node.Context = &ztype.DeltaContext[int32]{}

	fieldValue2Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValue2Node)
	// The field can be directly delta packed, therefore create a delta context
	fieldValue2Node.Context = &ztype.DeltaContext[uint64]{}

	fieldValue3Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValue3Node)

	fieldValue4Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValue4Node)
	// The field can be directly delta packed, therefore create a delta context
	fieldValue4Node.Context = &ztype.DeltaContext[int64]{}

	fieldValue5Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValue5Node)

	fieldColourValueNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldColourValueNode)
	// the field is a marshalable type, let the type itself decide if a delta
	// context is needed
	var fieldColourValuePtr *Colour
	if err := fieldColourValuePtr.ZserioCreatePackingContext(fieldColourValueNode); err != nil {
		return err
	}

	return nil
}

func (v *SubTypeArithmetics) ZserioInitPackingContext(contextNode *zserio.PackingContextNode) error {
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValue1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {

		traits := ztype.SignedBitFieldArrayTraits[int32]{NumBits: uint8(32)}
		fieldValue1Context.Init(&traits, int32(int32(v.Value1)))
	}

	if fieldValue2Context, ok := childrenNodes[1].Context.(*ztype.DeltaContext[uint64]); !ok {
		return errors.New("unknown context type")
	} else {

		traits := ztype.VarUInt64ArrayTraits{}
		fieldValue2Context.Init(&traits, uint64(uint64(v.Value2)))
	}

	if fieldValue4Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int64]); !ok {
		return errors.New("unknown context type")
	} else {

		traits := ztype.SignedBitFieldArrayTraits[int64]{NumBits: uint8(64)}
		fieldValue4Context.Init(&traits, int64(v.Value4))
	}

	if err := v.ColourValue.ZserioInitPackingContext(childrenNodes[5]); err != nil {
		return err
	}

	return nil
}

func (v *SubTypeArithmetics) UnmarshalZserioPacked(contextNode *zserio.PackingContextNode, r zserio.Reader) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValue1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		traits := ztype.SignedBitFieldArrayTraits[int32]{NumBits: uint8(32)}
		if tempValue, err := fieldValue1Context.Read(&traits, r); err == nil {
			v.Value1 = (SubtypedInt32)(tempValue)
		} else {
			return err
		}
	}

	if fieldValue2Context, ok := childrenNodes[1].Context.(*ztype.DeltaContext[uint64]); !ok {
		return errors.New("unknown context type")
	} else {
		traits := ztype.VarUInt64ArrayTraits{}
		if tempValue, err := fieldValue2Context.Read(&traits, r); err == nil {
			v.Value2 = (SubtypedVarUint64)(tempValue)
		} else {
			return err
		}
	}

	if tempValue, err := ztype.ReadFloat64(r); err == nil {
		v.Value3 = (SubtypedFloat64)(tempValue)
	} else {
		return err
	}

	if fieldValue4Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int64]); !ok {
		return errors.New("unknown context type")
	} else {
		traits := ztype.SignedBitFieldArrayTraits[int64]{NumBits: uint8(64)}
		if tempValue, err := fieldValue4Context.Read(&traits, r); err == nil {
			v.Value4 = (int64)(tempValue)
		} else {
			return err
		}
	}

	if tempValue, err := ztype.ReadFloat64(r); err == nil {
		v.Value5 = (DoubleSubtypedFloat64)(tempValue)
	} else {
		return err
	}

	if err = v.ColourValue.UnmarshalZserioPacked(childrenNodes[5], r); err != nil {
		return err
	}

	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *SubTypeArithmetics) MarshalZserioPacked(contextNode *zserio.PackingContextNode, w zserio.Writer) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValue1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldValue1Context.Write(&ztype.SignedBitFieldArrayTraits[int32]{NumBits: uint8(32)}, w, int32(int32(v.Value1))); err != nil {
			return err
		}
	}

	if fieldValue2Context, ok := childrenNodes[1].Context.(*ztype.DeltaContext[uint64]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldValue2Context.Write(&ztype.VarUInt64ArrayTraits{}, w, uint64(uint64(v.Value2))); err != nil {
			return err
		}
	}

	if err := ztype.WriteFloat64(w, float64(float64(v.Value3))); err != nil {
		return err
	}

	if fieldValue4Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int64]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldValue4Context.Write(&ztype.SignedBitFieldArrayTraits[int64]{NumBits: uint8(64)}, w, int64(v.Value4)); err != nil {
			return err
		}
	}

	if err := ztype.WriteFloat64(w, float64(float64(v.Value5))); err != nil {
		return err
	}

	if err := v.ColourValue.MarshalZserioPacked(childrenNodes[5], w); err != nil {
		return err
	}

	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *SubTypeArithmetics) ZserioInitializeOffsetsPacked(contextNode *zserio.PackingContextNode, bitPosition int) int {
	return 0
}

func (v *SubTypeArithmetics) ZserioBitSizePacked(contextNode *zserio.PackingContextNode, bitPosition int) (int, error) {
	endBitPosition := bitPosition
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValue1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldValue1Context.BitSizeOf(&ztype.SignedBitFieldArrayTraits[int32]{NumBits: uint8(32)}, endBitPosition, int32(int32(v.Value1))); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	if fieldValue2Context, ok := childrenNodes[1].Context.(*ztype.DeltaContext[uint64]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldValue2Context.BitSizeOf(&ztype.VarUInt64ArrayTraits{}, endBitPosition, uint64(uint64(v.Value2))); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	endBitPosition += 64

	if fieldValue4Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int64]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldValue4Context.BitSizeOf(&ztype.SignedBitFieldArrayTraits[int64]{NumBits: uint8(64)}, endBitPosition, int64(v.Value4)); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	endBitPosition += 64

	if delta, err := v.ColourValue.ZserioBitSizePacked(childrenNodes[5], endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	return endBitPosition - bitPosition, nil
}
